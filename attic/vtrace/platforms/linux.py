"""
Linux Platform Module
"""
# copyright (C) 2014 invisigoth - see LICENSE file for details
import os
import sys
import time
import shlex
import struct
import platform
import traceback
import collections

import envi
import envi.cli as e_cli
import envi.memory as e_mem
import envi.registers as e_reg

import envi.bexfile as e_bexfile
import envi.bexs.elf as e_bx_elf

import vtrace

import vtrace.archs.arm as v_arm
import vtrace.archs.i386 as v_i386
import vtrace.archs.amd64 as v_amd64

import vtrace.formats.elf as v_elf
import vtrace.platforms.base as v_base
#import vtrace.platforms.posix as v_posix

from ctypes import *
import ctypes.util as cutil

O_RDWR = 2
O_LARGEFILE = 0x8000

MAP_ANONYMOUS = 0x20
MAP_PRIVATE = 0x02

SIGTRAP = 5
SIGSTOP = 19

# mostly normal ptrace defs...
PT_TRACE_ME     = 0   # child declares it's being traced */
PT_READ_I       = 1   # read word in child's I space */
PT_READ_D       = 2   # read word in child's D space */
PT_READ_U       = 3   # read word in child's user structure */
PT_WRITE_I      = 4   # write word in child's I space */
PT_WRITE_D      = 5   # write word in child's D space */
PT_WRITE_U      = 6   # write word in child's user structure */
PT_CONTINUE     = 7   # continue the child */
PT_KILL         = 8   # kill the child process */
PT_STEP         = 9   # single step the child */

# Linux specific ptrace extensions
PT_GETREGS = 12
PT_SETREGS = 13
PT_GETFPREGS = 14
PT_SETFPREGS = 15
PT_ATTACH = 16
PT_DETACH = 17
PT_GETFPXREGS = 18
PT_SETFPXREGS = 19
PT_SYSCALL = 24
PT_SETOPTIONS = 0x4200
PT_GETEVENTMSG = 0x4201
PT_GETSIGINFO = 0x4202
PT_SETSIGINFO = 0x4203
# PT set options stuff.  ONLY TRACESYSGOOD may be used in 2.4...
PT_O_TRACESYSGOOD   = 0x00000001 # add 0x80 to TRAP when generated by syscall
# For each of the options below, the stop signal is (TRAP | PT_EVENT_FOO << 8)
PT_O_TRACEFORK      = 0x00000002 # Cause a trap at fork
PT_O_TRACEVFORK     = 0x00000004 # Cause a trap at vfork
PT_O_TRACECLONE     = 0x00000008 # Cause a trap at clone
PT_O_TRACEEXEC      = 0x00000010 # Cause a trap at exec
PT_O_TRACEVFORKDONE = 0x00000020 # Cause a trap when vfork done
PT_O_TRACEEXIT      = 0x00000040 # Cause a trap on exit
PT_O_MASK           = 0x0000007f
# Ptrace event types (TRAP | PT_EVENT_FOO << 8) means that type
# when using GETEVENTMSG for most of these, the new pid is the data
PT_EVENT_FORK       = 1
PT_EVENT_VFORK      = 2
PT_EVENT_CLONE      = 3
PT_EVENT_EXEC       = 4
PT_EVENT_VFORK_DONE = 5
PT_EVENT_EXIT       = 6

# Used to tell some of the additional events apart
SIG_LINUX_SYSCALL = SIGTRAP | 0x80
SIG_LINUX_CLONE = SIGTRAP | (PT_EVENT_CLONE << 8)
SIG_LINUX_EXIT = SIGTRAP | (PT_EVENT_EXIT << 8)
SIG_LINUX_FORK = SIGTRAP | (PT_EVENT_FORK << 8)
SIG_LINUX_VFORK = SIGTRAP | (PT_EVENT_VFORK << 8)


#class LinuxLocalWire(PyFilesWire):

#WIFSTOPPED(status)    (((status) & 0xff) == 0x7f)

# these can *not* come from os module...  we might be remotely
# debugging linux from windows...
def WIFSTOPPED(s):
    return ( s & 0xff ) == 0x7f

def WIFSIG(status):
    return (status >> 8) # NOTE: *must* not mask this down!

def WIFSIGNALED(s):
    return ((( s & 0x7f ) + 1 ) >> 1) > 0

def WIFEXITED(s):
    return (s & 0x7f) == 0


#def WIFSIGNALED(status):
#def WIFSTOPPED(status):

#def kernelversion():
    #return tuple([ int(v) for v in platform.release().split('-')[0].split('.') ])

class LinuxTrace(v_base.TracePlatform):

    def _loadCpuRegs(self, tid):
        return self.wire.loadregs(tid)

    def _saveCpuRegs(self, reglist):
        self.wire.saveregs(reglist)

    def _plat_getwire(self):
        # called when we need the local platform default wire
        import vtrace.wires.linux as vt_wire_linux
        return vt_wire_linux.LinuxWire()

    def _plat_init(self):

        self.setMeta('format','elf')
        self.sigpend = collections.deque()

        sysinfo = {
            'syscall':'syscall integer',
            'sysret':'syscall return value (after syscall only, if platform supported)',
        }
        self._hook_init("syscall",doc="fires before/after syscalls (+syscall mode)",**sysinfo)
        self._mode_init("syscall",doc="break on syscalls")

    def _plat_bexsyms(self, addr, size, name, path):

        fd = self._plat_openfd(path,mode='rb')
        if fd == None:
            # FIXME unitified print/event?
            self.vprint('_plat_openfd() failed: %s' % path)
            return

        elf = e_bx_elf.ElfFile(fd)
        return [ (a+addr,s,n,t) for (a,s,n,t) in elf.symbols() ]

    def _plat_memread(self, va, size):
        return self.wire.memread(va, size)

    def _plat_exec(self, cmdline):
        argv = shlex.split(cmdline)
        pid = self.wire.execute(argv)

        #self.pid = pid
        #self.initCpuCtx(pid)
        self._plat_fakeit(pid)

        return pid

    def _plat_attach(self, pid):
        self.wire.attach(pid)
        self._plat_fakeit(pid)

    def _plat_fakeit(self, pid):
        self.pid = pid
        self.initCpuCtx(pid)

        self._hook_fire('threadinit',{'tid':pid},pend=True)

        self._lib_findmaps('\x7fELF')

        for dirname in self.wire.listdir('/proc/%s/task' % pid):
            if not dirname.isdigit():
                continue

            tid = int(dirname)
            if tid == pid:
                continue

            self.wire.attach(tid)

            self.initCpuCtx(tid)
            self._hook_fire('threadinit',{'tid':pid},pend=True)

        # fake out a "windows style" break after procinit/threadinit
        self._hook_fire('break',{},pend=True)

    def _plat_pslist(self):
        pslist = []
        for dname in self.wire.listdir('/proc'):
            try:
                if not dname.isdigit():
                    continue

                cmdline = self._wire_filecat('/proc/%s/cmdline' % dname)
                cmdline = cmdline.replace("\x00"," ")
                if len(cmdline) > 0:
                    pslist.append((int(dname),cmdline))

            except Exception, e:
                print 'FAIL',e
                pass # Permissions...  quick process... whatev.

        return pslist

    def _plat_run(self):

        if self.sigpend:
            tid,status = self.sigpend.popleft()
            print "CACHED SIG",tid,status
            self._linux_gotsignal(tid,status)
            return

        sig = self.sig
        self.sig = None

        tids = self.threads.keys()
        signals = self.wire.run(self.pid, sig, tids)

        self.sigpend.extend(signals)

        tid,status = self.sigpend.popleft()
        self._linux_gotsignal(tid,status)

    def _plat_stepi(self):
        self.wire.stepi(self.tid)

    def _plat_detach(self):
        # finiCpuCtx() is handled above us! yay!
        tids = self.threads.keys()
        self.wire.detach( tids )

    def _linux_gotsignal(self, tid, status):

        sig = WIFSIG(status)

        #self.setCpuCtx(tid)
        self.initCpuCtx(tid)

        if WIFSTOPPED(status):

            # account for SIGSTOP on threads where the parent
            # hasn't notified us about them yet...
            if self.threads.get(tid) == None and sig == SIGSTOP:
                #self.tid = tid
                #self.threads[tid] = 1
                #self.initCpuCtx(tid)
                #self.wire.ptrace_opts(tid)
                print 'EARLY KID',tid,hex(self.getreg('rbp'))
                #self._hook_fire('threadinit',{'tid':self.tid})
                self.runagain = True
                return
                #self.stopclone[tid] = True
                #return

            #print "WAITED GOT",tid,sig
            #self.tid = tid

            if sig == SIGTRAP:

                if self._check_breaks():
                    return

                #if self._check_watchpoints():
                    #return

            self._clear_breaks()

            if sig == SIG_LINUX_CLONE:
                tid = self.wire.ptrace_event(tid)
                self.initCpuCtx(tid)
                self._hook_fire('threadinit',{'tid':self.tid})
                return

            #if sig == SIG_LINUX_FORK:
                #tid = self.ptrace_event(tid)
                #self.ptrace_opts(tid)
                #self.initCpuCtx(tid)
                #self._hook_fire('threadinit',{'tid':self.tid})
                #return

            #if sig == SIG_LINUX_VFORK:
                #tid = self.ptrace_event(tid)
                #self.ptrace_opts(tid)
                #self.initCpuCtx(tid)
                #self._hook_fire('threadinit',{'tid':tid})
                #return

            if sig == SIG_LINUX_EXIT:
                print 'SIG_LINUX_EXIT'
                exitcode = self.wire.ptrace_event(tid) >> 8
                if tid != self.pid:
                    self._hook_fire('threadexit',{'tid':tid,'exitcode':exitcode})
                    self.wire.detach([tid])
                    self.finiCpuCtx(tid,setid=self.pid)
                    return

                self.exitcode = exitcode
                self._hook_fire('procexit',{'pid':self.pid,'exitcode':exitcode})

                tids = self.shutCpuCtx()
                self.wire.detach(tids)
                #tids = self.threads.keys()
                #[ self.finiCpuCtx(tid) for tid in tids ]
                #for tid in self.threads.keys():
                    #self.finiCpuCtx(tid)
                    #self.wire.detach([tid])
                    #self.wire.ptrace(PT_DETACH, tid, 0, 0)

                return

            # FIXME assume all errant STOP signals are us...
            if sig == SIGSTOP:
                print('GOD DAMN ERRANT STOP TID %s' % tid)
                self.runagain = True
                return

            self.sig = sig
            self._hook_fire('signal',{'tid':self.pid,'sig':sig})
            return

        elif WIFEXITED(status):
            exitcode = sig
            if tid != self.pid:
                self._hook_fire('threadexit',{'tid':tid,'exitcode':exitcode})
                self.wire.detach([tid])
                self.finiCpuCtx(tid,setid=self.pid)
                return

            self.exitcode = exitcode
            self._hook_fire('procexit',{'pid':self.pid,'exitcode':self.exitcode})
            tids = self.shutCpuCtx()
            self.wire.detach( tids )
            return

        elif WIFSIGNALED(status):
            self.exitcode = sig
            self._hook_fire('procexit',{'pid':self.pid,'exitcode':self.exitcode})
            return

        else:
            print('WHAT THE HELL DID WIF DO?')
            self._hook_fire('break',{'tid':tid})
            return


    def addTraceHook(self, evtname, hookfunc):
        '''
        Add a callback for a specific tracer event.

        (See getTraceHooks() output for a list of events)
        '''
        hookfuncs = self.hooks.get(evtname)
        if hookfuncs == None:
            raise Exception('invalid event name: %s' % evtname)

        hookfuncs.append(hookfunc)

    def getTraceHooks(self):
        '''
        Retrieve a list of (evtname,hooklist) tuples for the current
        set of available event hooks.
        '''
        self.hooks.items()

    def delTraceHook(self, evtname, hookfunc):
        '''
        Remove a previously added trace hook function.

        Example:

            def wegetsignal(evtname,hookinfo):
                print("signal: %s" % hookinfo.get("sig"))

            t.addTraceHook("signal",wegetsignal)

            # do stuf until...
            # my hook is done hangin out...

            t.delTraceHook("signal", wegetsignal)

        '''
        hookfuncs = self.hooks.get(evtname)
        if hookfuncs == None:
            return
        hookfuncs.remove(hookfunc)


    #def fireTraceHooks(self, evtname, hookinfo):

    #def doAttachThread(self, tid, attached=False):
        #"""
        #Do the work for attaching a thread.  This must be *under*
        #attachThread() so callers in notifiers may call it (because
        #it's also gotta be thread wrapped).
        #"""
        #if not attached:
            #if _posix.ptrace(PT_ATTACH, tid, 0, 0) != 0:
                #raise Exception("ERROR ptrace attach failed for thread %d" % tid)

        # We may have already revcieved the stop signal
        #if not self._stopped_cache.pop( tid, None ):
            #os.waitpid(tid, 0x40000002)

        #self.setupPtraceOptions(tid)
        #self.pthreads.append(tid)

    #@v_base.threadwrap
    #def setupPtraceOptions(self, tid):
        #"""
        #Called per pid/tid to setup proper options
        #for ptrace.
        #"""

        #opts = PT_O_TRACESYSGOOD
        #if platform.release()[:3] in ('2.6','3.0','3.1','3.2'):
            #opts |= PT_O_TRACECLONE | PT_O_TRACEEXIT

        #self.ptrace(PT_SETOPTIONS, tid, 0, opts)

        #x = _posix.ptrace(PT_SETOPTIONS, tid, 0, opts)
        #if x != 0:
            #self.libc.perror('ptrace PT_SETOPTION failed for thread %d' % tid)

    #def threadsForPid(self, pid):
        #ret = []
        #tpath = "/proc/%s/task" % pid
        #if os.path.exists(tpath):
            #for pidstr in os.listdir(tpath):
                #ret.append(int(pidstr))
        #return ret

    #def platformProcessEvent(self, event):
        # Skim some linux specific events before passing to posix
        #tid, status = event
        #if os.WIFSTOPPED(status):
            #sig = status >> 8 # Cant use os.WSTOPSIG() here...
            #print('STOPPED: %d %d %.8x %d' % (self.pid, tid, status, sig))

            # Ok... this is a crazy little state engine that tries
            # to account for the discrepancies in how linux posts
            # signals to the debugger...

            # Thread Creation:
            # In each case below, the kernel may deliver
            # any of the 3 signals in any order...  ALSO
            # (and more importantly) *if* the kernel sends
            # SIGSTOP to the thread first, the debugger
            # will get a SIGSTOP *instead* of SIG_LINUX_CLONE
            # ( this will go back and forth on *ONE BOX* with
            #   the same kernel version... Finally squished it
            #   because it presents more frequently ( 1 in 10 )
            #   on my new ARM linux dev board. WTF?!1?!one?!? )
            #
            # Case 1 (SIG_LINUX_CLONE):
            #     debugger gets SIG_LINUX CLONE as expected
            #     and can then use ptrace(PT_GETEVENTMSG)
            #     to get new TID and attach as normal
            # Case 2 (SIGSTOP delivered to thread)
            #     Thread is already stoped and attached but
            #     parent debugger doesn't know yet.  We add
            #     the tid to the stopped_cache so when the
            #     kernel gets around to telling the debugger
            #     we don't wait on him again.
            # Case 3 (SIGSTOP delivered to debugger)
            #     In both case 2 and case 3, this will cause
            #     the SIG_LINUX_CLONE to be skipped.  Either
            #     way, we should head down into thread attach.
            #     ( The thread may be already stopped )
            #if sig == SIG_LINUX_SYSCALL:
                #self.fireNotifiers(vtrace.NOTIFY_SYSCALL)

            #elif sig == SIG_LINUX_EXIT:

                #ecode = self.getPtraceEvent() >> 8

                #if tid == self.getPid():
                    #self._fireExit( ecode )
                    #self.platformDetach()

                #else:
                    #self.detachThread(tid, ecode)

            #elif sig == SIG_LINUX_CLONE:
                # Handle a new thread here!
                #newtid = self.getPtraceEvent()
                #print('CLONE (new tid: %d)' % newtid)
                #self.attachThread(newtid, attached=True)

            #elif sig == SIGSTOP and tid != self.pid:
                #print('OMG IM THE NEW THREAD! %d' % tid)
                # We're not even a real event right now...
                #self.runAgain()
                #self._stopped_cache[tid] = True

            #elif sig == SIGSTOP:
                # If we are still 'exec()'ing, we havent hit the SIGTRAP
                # yet ( so our process info is still python, lets skip it )
                #if self.execing:
                    #self._stopped_hack = True
                    #self.setupPtraceOptions(tid)
                    #self.runAgain()

                #elif self._stopped_hack:
                    #newtid = self.getPtraceEvent(tid)
                    ##print("WHY DID WE GET *ANOTHER* STOP?: %d" % tid)
                    #print('PTRACE EVENT: %d' % newtid)
                    #self.attachThread(newtid, attached=True)

                #else: # on first attach...
                    #self._stopped_hack = True
                    #self.setupPtraceOptions(tid)
                    ##self.handlePosixSignal(sig)

            #FIXME eventually implement child catching!
            #else:
                #self.handlePosixSignal(sig)

            #return

        #_posix.PosixMixin.platformProcessEvent(self, event)

    #@v_base.threadwrap
    #def getPtraceEvent(self, tid=None):
    #def _plat_threads(self):
        #return self.threads.items()

    #def platformGetThreads(self):
        #ret = {}
        #for tid in self.pthreads:
            #ret[tid] = tid #FIXME make this pthread struct or stackbase soon
        #return ret

    def _plat_memmaps(self):
        maps = []

        mapbuf = self.wire.filecat('/proc/%d/maps' % self.pid)
        for line in mapbuf.split('\n'):
            if not line:
                continue

            perms = 0
            mapparts = line.split(None,5)

            basestr,maxstr = mapparts[0].split('-',1)

            maxva = int(maxstr,16)
            baseva = int(basestr,16)

            pathstr = None
            permstr = mapparts[1]
            if len(mapparts) > 5:
                pathstr = mapparts[5]

            #addrs = sline[0]
            #permstr = sline[1]
            #fname = sline[-1].strip()
            #addrs = addrs.split("-")
            #base = long(addrs[0],16)
            #max = long(addrs[1],16)
            #mlen = max-base

            if "r" in permstr:
                perms |= e_mem.MM_READ
            if "w" in permstr:
                perms |= e_mem.MM_WRITE
            if "x" in permstr:
                perms |= e_mem.MM_EXEC
            #if "p" in permstr:
                #pass

            maps.append((baseva,maxva-baseva,perms,pathstr))

        return maps

    #def platformGetFds(self):
    def _plat_fds(self):
        fds = []
        for name in self.wire.listdir('/proc/%d/fd' % self.pid ):
        #for name in os.listdir("/proc/%d/fd/" % self.pid):
            if not name.isdigit():
                continue

            fdnum = int(name)
            fdtype = vtrace.FD_UNKNOWN

            link = self.wire.readlink('/proc/%d/fd/%s' % (self.pid,name) )

            if "socket:" in link:
                fdtype = vtrace.FD_SOCKET
            elif "pipe:" in link:
                fdtype = vtrace.FD_PIPE
            elif "/" in link:
                fdtype = vtrace.FD_FILE

            fds.append((fdnum,fdtype,link))

            #except:
                #traceback.print_exc()

        return fds

############################################################################
#
# NOTE: Both of these use class locals set by the i386/amd64 variants
#
    #@v_base.threadwrap
    #def platformGetRegCtx(self, tid):
        #ctx = self.archGetRegCtx()
        #u = self.user_reg_struct()
        #if self.ptrace(PT_GETREGS, tid, 0, addressof(u)) == -1:
            #raise Exception("Error: ptrace(PT_GETREGS...) failed!")
        #ctx._rctx_Import(u)
        #return ctx

    #@v_base.threadwrap
    #def platformSetRegCtx(self, tid, ctx):
        #u = self.user_reg_struct()
        # Populate the reg struct with the current values (to allow for
        # any regs in that struct that we don't track... *fs_base*ahem*
        #if self.ptrace(PT_GETREGS, tid, 0, addressof(u)) == -1:
            #raise Exception("Error: ptrace(PT_GETREGS...) failed!")
        #ctx._rctx_Export(u)
        #if self.ptrace(PT_SETREGS, tid, 0, addressof(u)) == -1:
            #raise Exception("Error: ptrace(PT_SETREGS...) failed!")

        """
        for i in intel_dbgregs:
            val = ctx.getRegister(self.dbgidx + i)
            offset = self.user_dbg_offset + (self.psize * i)
            if v_posix.ptrace(v_posix.PT_WRITE_U, tid, offset, val) != 0:
                self.libc.perror('PT_WRITE_U failed for debug%d' % i)
                #raise Exception("PT_WRITE_U for debug%d failed!" % i)
        """

class Linuxi386Trace(
        LinuxTrace,
        v_i386.i386Trace,
        v_base.TraceBase):

    #user_reg_struct = user_regs_i386
    #user_dbg_offset = 252
    #reg_val_mask = 0xffffffff

    def __init__(self):
        v_base.TraceBase.__init__(self)
        v_i386.i386Trace.__init__(self)
        LinuxTrace.__init__(self)

        # Pre-calc the index of the debug regs
        self.dbgidx = self.archGetRegCtx().getRegisterIndex("debug0")

    #@v_base.threadwrap
    def platformGetRegCtx(self, tid):
        ctx = LinuxMixin.platformGetRegCtx( self, tid )
        for i in intel_dbgregs:
            offset = self.user_dbg_offset + (self.psize * i)
            r = v_posix.ptrace(v_posix.PT_READ_U, tid, offset, 0)
            ctx.setRegister(self.dbgidx+i, r & self.reg_val_mask)
        return ctx

    #@v_base.threadwrap
    def platformSetRegCtx(self, tid, ctx):
        LinuxMixin.platformSetRegCtx( self, tid, ctx )
        for i in intel_dbgregs:
            val = ctx.getRegister(self.dbgidx + i)
            offset = self.user_dbg_offset + (self.psize * i)
            if v_posix.ptrace(v_posix.PT_WRITE_U, tid, offset, val) != 0:
                self.libc.perror('PT_WRITE_U failed for debug%d' % i)

    #@v_base.threadwrap
    def platformAllocateMemory(self, size, perms=e_mem.MM_RWX, suggestaddr=0):
        sp = self.getStackCounter()
        pc = self.getProgramCounter()

        # Xlate perms (mmap is backward)
        realperm = 0
        if perms & e_mem.MM_READ:
            realperm |= 1
        if perms & e_mem.MM_WRITE:
            realperm |= 2
        if perms & e_mem.MM_EXEC:
            realperm |= 4

        #mma is struct of mmap args for linux syscall
        mma = struct.pack("<6L", suggestaddr, size, realperm, MAP_ANONYMOUS|MAP_PRIVATE, 0, 0)

        regsave = self.getRegisters()

        stacksave = self.readMemory(sp, len(mma))
        ipsave = self.readMemory(pc, 2)

        SYS_mmap = 90

        self.writeMemory(sp, mma)
        self.writeMemory(pc, "\xcd\x80")
        self.setRegisterByName("eax", SYS_mmap)
        self.setRegisterByName("ebx", sp)
        self._syncRegs()

        try:
            # Step over our syscall instruction
            tid = self.getMeta("ThreadId", 0)
            self.platformStepi()
            os.waitpid(tid, 0)
            eax = self.getRegisterByName("eax")
            if eax & 0x80000000:
                raise Exception("Linux mmap syscall error: %d" % eax)
            return eax

        finally:
            # Clean up all our fux0ring
            self.writeMemory(sp, stacksave)
            self.writeMemory(pc, ipsave)
            self.setRegisters(regsave)

class LinuxAmd64Trace(
            LinuxTrace,
            v_amd64.Amd64Trace,
            v_base.TraceBase,
        ):
    pass

    #def __init__(self, wire=None):

    #user_reg_struct = user_regs_amd64
    #user_dbg_offset = 848
    #reg_val_mask = 0xffffffffffffffff

    #def _trace_init(self):
        #pass

    #def _plat_loadregs(self, tid, regs):
        #regs.load( self.wire.loadregs(tid) )
        #u = self.user_reg_struct()
        #if self.ptrace(PT_GETREGS, tid, 0, addressof(u)) == -1:
            #raise Exception("Error: ptrace(PT_GETREGS...) failed!")
        #regs.loadattr(u)

    #def _plat_saveregs(self, tid, regs):
        #self.wire.saveregs( tid, regs.save() )

    #@v_base.threadwrap
    #def platformGetRegCtx(self, tid):
        #ctx = LinuxMixin.platformGetRegCtx( self, tid )
        #for i in intel_dbgregs:
            #offset = self.user_dbg_offset + (self.psize * i)
            #r = v_posix.ptrace(v_posix.PT_READ_U, tid, offset, 0)
            #ctx.setRegister(self.dbgidx+i, r & self.reg_val_mask)
        #return ctx

    #@v_base.threadwrap
    #def platformSetRegCtx(self, tid, ctx):
        #LinuxMixin.platformSetRegCtx( self, tid, ctx )
        #for i in intel_dbgregs:
            #val = ctx.getRegister(self.dbgidx + i)
            #offset = self.user_dbg_offset + (self.psize * i)
            #if v_posix.ptrace(v_posix.PT_WRITE_U, tid, offset, val) != 0:
                #self.libc.perror('PT_WRITE_U failed for debug%d' % i)

arm_break_be = 'e7f001f0'.decode('hex')
arm_break_le = 'f001f0e7'.decode('hex')

class LinuxArmTrace(
        v_base.TraceBase,
        LinuxTrace,
        v_arm.ArmMixin):

    #user_reg_struct = user_regs_arm
    #reg_val_mask = 0xffffffff

    def __init__(self):
        vtrace.Trace.__init__(self)
        v_base.TraceBase.__init__(self)
        v_arm.ArmMixin.__init__(self)
        LinuxMixin.__init__(self)

        self._break_after_bp = False
        self._step_cleanup = []

    def _fireStep(self):
        # See notes below about insanity...
        if self._step_cleanup != None:
            [ self.writeMemory( bva, bytes ) for (bva,bytes) in self._step_cleanup ]
            self._step_cleanup = None
        return v_base.TraceBase._fireStep( self )

    def archGetBreakInstr(self):
        return arm_break_le

    def platformStepi(self):
        # This is a total rediculous hack to account
        # for the fact that the arm platform couldn't
        # be bothered to implement single stepping in
        # the stupid hardware...

        self.stepping = True

        pc = self.getProgramCounter()
        op = self.parseOpcode( pc )

        branches = op.getBranches( self )
        if not branches:
            raise Exception('''
                    The branches for the instruction %r were not decoded correctly.  This means that
                    we cant properly predict the possible next instruction executions in a way that allows us
                    to account for the STUPID INSANE FACT THAT THERE IS NO HARDWARE SINGLE STEP CAPABILITY ON
                    ARM (non-realtime or JTAG anyway).  We *would* have written invalid instructions to each
                    of those locations and cleaned them up before you ever knew anything was amiss... which is
                    how we pretend arm can single step... even though IT CANT. (please tell visi...)
            ''' % op)

        # Save the memory at the branches for later
        # restoration in the _fireStep callback.

        self._step_cleanup = []
        for bva,bflags in op.getBranches( self ):
            self._step_cleanup.append( (bva, self.readMemory( bva, 4 )) )
            self.writeMemory( bva, arm_break_le )

        tid = self.getMeta('ThreadId')

        if v_posix.ptrace(v_posix.PT_CONTINUE, tid, 0, 0) != 0:
            raise Exception("ERROR ptrace failed for tid %d" % tid)

